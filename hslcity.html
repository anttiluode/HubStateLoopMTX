<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H/S/L Fractal - Nested Rhythms</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #0a0a0a 0%, #1a1a2e 50%, #000 100%);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            max-width: 300px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        button {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff6b9d;
            font-size: 11px;
        }
        
        .color-box {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ffaa00;
            max-width: 250px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <canvas id="fractalCanvas"></canvas>
    
    <div class="controls">
        <h3 style="margin-top: 0; color: #00ff88;">H/S/L Fractal Controls</h3>
        
        <div class="control-group">
            <label>Recursion Depth</label>
            <input type="range" id="depth" min="3" max="8" value="5">
            <span id="depthValue">5</span>
        </div>
        
        <div class="control-group">
            <label>Time Speed</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
            <span id="speedValue">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Branch Angle</label>
            <input type="range" id="angle" min="10" max="90" value="45">
            <span id="angleValue">45°</span>
        </div>
        
        <div class="control-group">
            <label>Pulsation Intensity</label>
            <input type="range" id="pulse" min="0" max="2" step="0.1" value="0.8">
            <span id="pulseValue">0.8</span>
        </div>
        
        <button onclick="resetAnimation()">Reset</button>
        <button onclick="togglePause()">Pause</button>
        <button onclick="randomize()">Randomize</button>
    </div>
    
    <div class="info">
        <h4 style="margin-top: 0; color: #ffaa00;">Fractal Patterns</h4>
        <p><strong>H (Hubs):</strong> Branching points where new scales emerge</p>
        <p><strong>S (States):</strong> Transition paths between scales</p>
        <p><strong>L (Loops):</strong> Stable cycles at each level</p>
        <p style="margin-bottom: 0;"><em>Click anywhere to plant new growth seeds!</em></p>
    </div>
    
    <div class="legend">
        <h4 style="margin-top: 0; color: #ff6b9d;">Pattern Legend</h4>
        <div><span class="color-box" style="background: #ff4444;"></span> H - Hub Events</div>
        <div><span class="color-box" style="background: #44ff44;"></span> L - Loop Cycles</div>
        <div><span class="color-box" style="background: #4444ff;"></span> S - State Transitions</div>
        <div><span class="color-box" style="background: #ffff44;"></span> Nested Patterns</div>
    </div>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let time = 0;
        let animationId;
        let isPaused = false;
        let growthSeeds = [];
        
        // Control elements
        const depthSlider = document.getElementById('depth');
        const speedSlider = document.getElementById('speed');
        const angleSlider = document.getElementById('angle');
        const pulseSlider = document.getElementById('pulse');
        
        // Update display values
        function updateDisplayValues() {
            document.getElementById('depthValue').textContent = depthSlider.value;
            document.getElementById('speedValue').textContent = speedSlider.value;
            document.getElementById('angleValue').textContent = angleSlider.value + '°';
            document.getElementById('pulseValue').textContent = pulseSlider.value;
        }
        
        // HSL Pattern Generator
        class HSLPattern {
            constructor(x, y, angle, scale, depth, patternType = 'h') {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.scale = scale;
                this.depth = depth;
                this.patternType = patternType; // 'h', 's', 'l'
                this.phase = Math.random() * Math.PI * 2;
                this.children = [];
                this.age = 0;
                
                if (depth > 0) {
                    this.generateChildren();
                }
            }
            
            generateChildren() {
                const branchAngle = parseInt(angleSlider.value) * Math.PI / 180;
                const childScale = this.scale * 0.6;
                const childDepth = this.depth - 1;
                
                // Generate pattern-specific children
                if (this.patternType === 'h') {
                    // Hubs branch into multiple states
                    for (let i = 0; i < 3; i++) {
                        const childAngle = this.angle + (i - 1) * branchAngle;
                        const childType = ['s', 'l', 's'][i];
                        this.children.push(new HSLPattern(
                            this.x + Math.cos(childAngle) * this.scale * 40,
                            this.y + Math.sin(childAngle) * this.scale * 40,
                            childAngle,
                            childScale,
                            childDepth,
                            childType
                        ));
                    }
                } else if (this.patternType === 'l') {
                    // Loops create circular patterns with occasional hubs
                    for (let i = 0; i < 4; i++) {
                        const childAngle = this.angle + i * Math.PI / 2;
                        const childType = i === 0 ? 'h' : 'l';
                        this.children.push(new HSLPattern(
                            this.x + Math.cos(childAngle) * this.scale * 30,
                            this.y + Math.sin(childAngle) * this.scale * 30,
                            childAngle,
                            childScale,
                            childDepth,
                            childType
                        ));
                    }
                } else { // 's' states
                    // States transition to loops or hubs
                    const childType = Math.random() > 0.5 ? 'l' : 'h';
                    this.children.push(new HSLPattern(
                        this.x + Math.cos(this.angle) * this.scale * 50,
                        this.y + Math.sin(this.angle) * this.scale * 50,
                        this.angle + (Math.random() - 0.5) * branchAngle,
                        childScale,
                        childDepth,
                        childType
                    ));
                }
            }
            
            update(dt) {
                this.age += dt;
                this.children.forEach(child => child.update(dt));
            }
            
            draw() {
                const pulseIntensity = parseFloat(pulseSlider.value);
                
                // Calculate pulsation based on pattern type and time
                let pulse = 1;
                if (this.patternType === 'h') {
                    pulse = 1 + Math.sin(time * 3 + this.phase) * pulseIntensity * 0.5;
                } else if (this.patternType === 'l') {
                    pulse = 1 + Math.sin(time + this.phase) * pulseIntensity * 0.2;
                } else {
                    pulse = 1 + Math.sin(time * 2 + this.phase) * pulseIntensity * 0.3;
                }
                
                // Set color based on pattern type
                let color;
                if (this.patternType === 'h') {
                    color = `rgba(255, ${100 + pulse * 50}, ${100 + pulse * 50}, ${0.8 * this.scale})`;
                } else if (this.patternType === 'l') {
                    color = `rgba(${100 + pulse * 50}, 255, ${100 + pulse * 50}, ${0.7 * this.scale})`;
                } else {
                    color = `rgba(${100 + pulse * 50}, ${100 + pulse * 50}, 255, ${0.6 * this.scale})`;
                }
                
                // Draw the node
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw glow effect
                const radius = this.scale * 15 * pulse;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw core
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pattern-specific shapes
                if (this.patternType === 'h') {
                    // Draw radiating lines for hubs
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2 * this.scale;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + time;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * radius * 0.8, Math.sin(angle) * radius * 0.8);
                        ctx.stroke();
                    }
                } else if (this.patternType === 'l') {
                    // Draw circular pattern for loops
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3 * this.scale;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Draw connections to children
                this.children.forEach(child => {
                    ctx.strokeStyle = `rgba(255, 255, 100, ${0.3 * this.scale})`;
                    ctx.lineWidth = 1 * this.scale;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(child.x, child.y);
                    ctx.stroke();
                    
                    child.draw();
                });
            }
        }
        
        // Main fractal system
        let rootPatterns = [];
        
        function initializeFractal() {
            rootPatterns = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const depth = parseInt(depthSlider.value);
            
            // Create initial patterns
            rootPatterns.push(new HSLPattern(centerX, centerY, 0, 1, depth, 'h'));
            
            // Add some growth seeds
            growthSeeds.forEach(seed => {
                rootPatterns.push(new HSLPattern(seed.x, seed.y, seed.angle, 0.8, depth - 1, seed.type));
            });
        }
        
        function animate() {
            if (!isPaused) {
                time += parseFloat(speedSlider.value) * 0.02;
                
                // Clear canvas
                ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw patterns
                rootPatterns.forEach(pattern => {
                    pattern.update(0.016);
                    pattern.draw();
                });
                
                // Draw background grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Control functions
        function resetAnimation() {
            time = 0;
            growthSeeds = [];
            initializeFractal();
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        function randomize() {
            growthSeeds = [];
            for (let i = 0; i < 5; i++) {
                growthSeeds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    angle: Math.random() * Math.PI * 2,
                    type: ['h', 's', 'l'][Math.floor(Math.random() * 3)]
                });
            }
            initializeFractal();
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            growthSeeds.push({
                x: x,
                y: y,
                angle: Math.random() * Math.PI * 2,
                type: ['h', 's', 'l'][Math.floor(Math.random() * 3)]
            });
            
            initializeFractal();
        });
        
        [depthSlider, speedSlider, angleSlider, pulseSlider].forEach(slider => {
            slider.addEventListener('input', updateDisplayValues);
        });
        
        depthSlider.addEventListener('change', initializeFractal);
        angleSlider.addEventListener('change', initializeFractal);
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initializeFractal();
        });
        
        // Initialize
        updateDisplayValues();
        initializeFractal();
        animate();
    </script>
</body>
</html>