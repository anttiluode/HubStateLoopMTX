<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H/S/L Fractal City - Night Metropolis</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #00ff88;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
            appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 8px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            cursor: pointer;
            border: 2px solid #000;
        }
        
        button {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff6b9d;
            font-size: 10px;
            backdrop-filter: blur(10px);
        }
        
        .color-box {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            vertical-align: middle;
            border-radius: 2px;
        }
        
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ffaa00;
            max-width: 250px;
            font-size: 10px;
            backdrop-filter: blur(10px);
        }
        
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ccff;
            font-size: 10px;
            backdrop-filter: blur(10px);
        }
        
        .value {
            color: #00ff88;
            font-weight: bold;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 18px;
            text-align: center;
        }
        
        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div>INITIALIZING CITY MATRIX...</div>
        <div style="margin-top: 10px; font-size: 12px;">Loading Three.js & Shaders</div>
    </div>

    <div id="interface" class="hidden">
        <div class="controls">
            <h3 style="margin-top: 0; color: #00ff88; font-size: 14px;">CITY MATRIX</h3>
            
            <div class="control-group">
                <label>Growth Depth</label>
                <input type="range" id="depth" min="2" max="7" value="4">
                <span class="value" id="depthValue">4</span>
            </div>
            
            <div class="control-group">
                <label>Pulse Speed</label>
                <input type="range" id="speed" min="0.1" max="4" step="0.1" value="1.5">
                <span class="value" id="speedValue">1.5</span>
            </div>
            
            <div class="control-group">
                <label>District Spread</label>
                <input type="range" id="spread" min="0.5" max="2" step="0.1" value="1">
                <span class="value" id="spreadValue">1.0</span>
            </div>
            
            <div class="control-group">
                <label>Traffic Flow</label>
                <input type="range" id="traffic" min="0" max="2" step="0.1" value="1">
                <span class="value" id="trafficValue">1.0</span>
            </div>
            
            <button onclick="resetCity()">RESET</button>
            <button onclick="togglePause()">PAUSE</button>
            <button onclick="flythrough()">FLY</button>
            <button onclick="micToggle()">ðŸŽ¤ MIC</button>
        </div>
        
        <div class="info">
            <h4 style="margin-top: 0; color: #ffaa00;">DISTRICT TYPES</h4>
            <p><strong>H-HUBS:</strong> Central towers, transit nexus</p>
            <p><strong>S-STATES:</strong> Highways, data flows</p>
            <p><strong>L-LOOPS:</strong> Residential blocks, circuits</p>
            <p style="margin-bottom: 0;"><em>Click to plant new districts!</em></p>
        </div>
        
        <div class="legend">
            <h4 style="margin-top: 0; color: #ff6b9d;">CITY LEGEND</h4>
            <div><span class="color-box" style="background: #ff4444;"></span>H - Hub Districts</div>
            <div><span class="color-box" style="background: #44ff44;"></span>L - Loop Networks</div>
            <div><span class="color-box" style="background: #4444ff;"></span>S - State Highways</div>
            <div><span class="color-box" style="background: #ffff44;"></span>Traffic Flow</div>
        </div>
        
        <div class="stats">
            <h4 style="margin-top: 0; color: #00ccff;">CITY STATS</h4>
            <div>Districts: <span class="value" id="districtCount">0</span></div>
            <div>Buildings: <span class="value" id="buildingCount">0</span></div>
            <div>Traffic: <span class="value" id="trafficCount">0</span></div>
            <div>FPS: <span class="value" id="fpsCounter">60</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
            onerror="loadThreeJSFallback()" 
            onload="window.THREE_LOADED = true"></script>
    <script>
        // Fallback Three.js loader
        function loadThreeJSFallback() {
            console.log('Primary Three.js CDN failed, trying fallback...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/three@0.128.0/build/three.min.js';
            script.onload = () => window.THREE_LOADED = true;
            script.onerror = () => {
                console.error('All Three.js CDNs failed - running fallback city');
                runFallbackCity();
            };
            document.head.appendChild(script);
        }
        
        // 2D Canvas fallback if Three.js completely fails
        function runFallbackCity() {
            document.getElementById('loading').innerHTML = `
                <div style="color: #ffaa00;">3D ENGINE UNAVAILABLE</div>
                <div style="margin-top: 10px; font-size: 12px;">Running 2D city visualization...</div>
            `;
            
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('interface').classList.remove('hidden');
                init2DCity();
            }, 1000);
        }
        
        // Enhanced 2D city with controls integration
        function init2DCity() {
            const canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '-1';
            document.body.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            let time = 0;
            let districts = [];
            
            // Create initial district pattern
            function createDistrict(x, y, type, depth = 3) {
                const district = {
                    x: x,
                    y: y,
                    type: type,
                    phase: Math.random() * Math.PI * 2,
                    children: []
                };
                
                if (depth > 0) {
                    const childCount = type === 'h' ? 4 : type === 'l' ? 3 : 2;
                    for (let i = 0; i < childCount; i++) {
                        const angle = (i / childCount) * Math.PI * 2;
                        const distance = 60 + Math.random() * 40;
                        const childX = x + Math.cos(angle) * distance;
                        const childY = y + Math.sin(angle) * distance;
                        const childType = ['h', 's', 'l'][Math.floor(Math.random() * 3)];
                        district.children.push(createDistrict(childX, childY, childType, depth - 1));
                    }
                }
                
                return district;
            }
            
            // Initialize with center district
            districts.push(createDistrict(canvas.width / 2, canvas.height / 2, 'h', parseInt(controls.depth.value)));
            
            // Update stats for 2D mode
            function updateStats2D() {
                function countDistricts(district) {
                    let count = 1;
                    district.children.forEach(child => count += countDistricts(child));
                    return count;
                }
                
                const totalDistricts = districts.reduce((sum, d) => sum + countDistricts(d), 0);
                document.getElementById('districtCount').textContent = totalDistricts;
                document.getElementById('buildingCount').textContent = totalDistricts * 5; // Estimated
                document.getElementById('trafficCount').textContent = Math.floor(totalDistricts * 2);
                
                const now = performance.now();
                if (!updateStats2D.lastTime) updateStats2D.lastTime = now;
                const fps = Math.round(1000 / (now - updateStats2D.lastTime));
                updateStats2D.lastTime = now;
                document.getElementById('fpsCounter').textContent = fps;
            }
            
            // Draw district recursively
            function drawDistrict(district) {
                const speedFactor = parseFloat(controls.speed.value);
                let pulse = 1;
                
                if (district.type === 'h') {
                    pulse = 1 + Math.sin(time * 3 * speedFactor + district.phase) * 0.5;
                } else if (district.type === 'l') {
                    pulse = 1 + Math.sin(time * speedFactor + district.phase) * 0.2;
                } else {
                    pulse = 1 + Math.sin(time * 2 * speedFactor + district.phase) * 0.3;
                }
                
                const size = 15 * pulse;
                
                // Get color based on type
                let hue = 0;
                switch (district.type) {
                    case 'h': hue = 0; break;   // Red
                    case 'l': hue = 120; break; // Green
                    case 's': hue = 240; break; // Blue
                }
                
                // Draw glow
                const gradient = ctx.createRadialGradient(district.x, district.y, 0, district.x, district.y, size * 2);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.8)`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(district.x - size * 2, district.y - size * 2, size * 4, size * 4);
                
                // Draw core
                ctx.fillStyle = `hsla(${hue}, 90%, 70%, 0.9)`;
                ctx.fillRect(district.x - size/2, district.y - size/2, size, size);
                
                // Draw connections to children
                district.children.forEach(child => {
                    ctx.strokeStyle = `hsla(60, 80%, 60%, 0.6)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(district.x, district.y);
                    ctx.lineTo(child.x, child.y);
                    ctx.stroke();
                    
                    drawDistrict(child);
                });
            }
            
            function animate2D() {
                if (!isPaused) {
                    time += 0.016;
                    
                    // Clear with dark background
                    ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw grid
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.lineWidth = 1;
                    const gridSize = 50;
                    for (let x = 0; x < canvas.width; x += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    for (let y = 0; y < canvas.height; y += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Draw all districts
                    districts.forEach(district => drawDistrict(district));
                    
                    updateStats2D();
                }
                
                requestAnimationFrame(animate2D);
            }
            
            // Click to add new districts
            canvas.addEventListener('click', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                const type = ['h', 's', 'l'][Math.floor(Math.random() * 3)];
                const depth = Math.max(1, parseInt(controls.depth.value) - 1);
                districts.push(createDistrict(x, y, type, depth));
            });
            
            // Override reset function for 2D
            window.resetCity = () => {
                time = 0;
                districts = [];
                districts.push(createDistrict(canvas.width / 2, canvas.height / 2, 'h', parseInt(controls.depth.value)));
            };
            
            animate2D();
            console.log('Enhanced 2D Fallback city running with full controls!');
        }
        
        // Check if Three.js loads within reasonable time
        setTimeout(() => {
            if (!window.THREE_LOADED && typeof THREE === 'undefined') {
                console.log('Three.js taking too long, loading fallback...');
                loadThreeJSFallback();
            }
        }, 3000);
    </script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let time = 0;
        let isPaused = false;
        let cityNodes = [];
        let buildings = [];
        let roads = [];
        let vehicles = [];
        let audioContext, microphone, analyzer;
        let micActive = false;
        let isFlying = false;
        let flyStartTime = 0;
        let originalCameraPos = new THREE.Vector3();
        
        // Controls
        const controls = {
            depth: document.getElementById('depth'),
            speed: document.getElementById('speed'),
            spread: document.getElementById('spread'),
            traffic: document.getElementById('traffic')
        };
        
        // City Node Class - represents H/S/L fractal nodes as city districts
        class CityNode {
            constructor(x, y, z, type, scale, depth, parent = null) {
                this.position = new THREE.Vector3(x, y, z);
                this.type = type; // 'h', 's', 'l'
                this.scale = scale;
                this.depth = depth;
                this.parent = parent;
                this.children = [];
                this.phase = Math.random() * Math.PI * 2;
                this.intensity = 1;
                this.age = 0;
                this.buildings = [];
                this.lastPulse = 0;
                
                this.generateBuildings();
                if (depth > 0) {
                    this.generateChildren();
                }
            }
            
            generateChildren() {
                const spreadFactor = parseFloat(controls.spread.value);
                const childDepth = this.depth - 1;
                const childScale = this.scale * (0.6 + Math.random() * 0.2);
                
                let childCount = 0;
                let childTypes = [];
                
                if (this.type === 'h') {
                    // Hubs spawn multiple districts
                    childCount = 3 + Math.floor(Math.random() * 2);
                    childTypes = ['s', 'l', 's', 'l', 'h'];
                } else if (this.type === 'l') {
                    // Loops create circular neighborhoods
                    childCount = 4;
                    childTypes = ['l', 'l', 's', 'h'];
                } else {
                    // States branch linearly
                    childCount = 1 + Math.floor(Math.random() * 2);
                    childTypes = ['l', 'h'];
                }
                
                for (let i = 0; i < childCount; i++) {
                    const angle = (i / childCount) * Math.PI * 2 + Math.random() * 0.5;
                    const distance = (50 + Math.random() * 30) * this.scale * spreadFactor;
                    const height = Math.random() * 10 - 5;
                    
                    const childX = this.position.x + Math.cos(angle) * distance;
                    const childZ = this.position.z + Math.sin(angle) * distance;
                    const childY = this.position.y + height;
                    
                    const childType = childTypes[i % childTypes.length];
                    const child = new CityNode(childX, childY, childZ, childType, childScale, childDepth, this);
                    this.children.push(child);
                    
                    // Create road connection
                    createRoad(this, child);
                }
            }
            
            generateBuildings() {
                const buildingCount = Math.floor(this.scale * (3 + Math.random() * 7));
                
                for (let i = 0; i < buildingCount; i++) {
                    const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.3;
                    const distance = Math.random() * 20 * this.scale;
                    const x = this.position.x + Math.cos(angle) * distance;
                    const z = this.position.z + Math.sin(angle) * distance;
                    
                    let height = 10 + Math.random() * 40;
                    if (this.type === 'h') height *= 2; // Taller hub buildings
                    if (this.type === 'l') height *= 0.5; // Shorter loop buildings
                    
                    const building = createBuilding(x, this.position.y, z, height, this.type, this.phase + i);
                    this.buildings.push(building);
                }
            }
            
            update(deltaTime) {
                this.age += deltaTime;
                
                // Calculate pulse based on type
                let pulse = 1;
                const speedFactor = parseFloat(controls.speed.value);
                
                if (this.type === 'h') {
                    pulse = 1 + Math.sin(time * 3 * speedFactor + this.phase) * 0.5;
                    if (pulse > 1.4 && time - this.lastPulse > 1) {
                        this.triggerHubEvent();
                        this.lastPulse = time;
                    }
                } else if (this.type === 'l') {
                    pulse = 1 + Math.sin(time * speedFactor + this.phase) * 0.2;
                } else {
                    pulse = 1 + Math.sin(time * 2 * speedFactor + this.phase) * 0.3;
                }
                
                this.intensity = pulse;
                
                // Update building materials
                this.buildings.forEach(building => {
                    if (building.material) {
                        const color = this.getTypeColor();
                        building.material.emissive.setRGB(
                            color.r * pulse * 0.3,
                            color.g * pulse * 0.3,
                            color.b * pulse * 0.3
                        );
                    }
                });
                
                // Update children
                this.children.forEach(child => child.update(deltaTime));
            }
            
            triggerHubEvent() {
                // Hub pulse event - affects entire city
                if (Math.random() > 0.7) {
                    spawnVehicleBurst(this.position);
                    createFireworks(this.position);
                }
            }
            
            getTypeColor() {
                switch (this.type) {
                    case 'h': return { r: 1, g: 0.3, b: 0.3 };
                    case 'l': return { r: 0.3, g: 1, b: 0.3 };
                    case 's': return { r: 0.3, g: 0.3, b: 1 };
                    default: return { r: 1, g: 1, b: 0.3 };
                }
            }
        }
        
        // Vehicle system
        class Vehicle {
            constructor(startNode, targetNode) {
                this.startNode = startNode;
                this.targetNode = targetNode;
                this.position = startNode.position.clone();
                this.progress = 0;
                this.speed = 0.3 + Math.random() * 0.7;
                this.mesh = createVehicleMesh();
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                const trafficFactor = parseFloat(controls.traffic.value);
                this.progress += this.speed * trafficFactor * deltaTime;
                
                if (this.progress >= 1) {
                    // Reached destination, find new target
                    this.startNode = this.targetNode;
                    if (this.targetNode.children.length > 0) {
                        this.targetNode = this.targetNode.children[Math.floor(Math.random() * this.targetNode.children.length)];
                    } else if (this.targetNode.parent) {
                        this.targetNode = this.targetNode.parent;
                    }
                    this.progress = 0;
                }
                
                // Interpolate position
                this.position.lerpVectors(this.startNode.position, this.targetNode.position, this.progress);
                this.position.y += 2; // Keep vehicles above ground
                this.mesh.position.copy(this.position);
                
                // Orient towards target
                this.mesh.lookAt(this.targetNode.position);
            }
            
            destroy() {
                scene.remove(this.mesh);
            }
        }
        
        // Three.js setup
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 50, 500);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 150, 200);
            camera.lookAt(0, 0, 0);
            originalCameraPos = camera.position.clone();
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const moonLight = new THREE.DirectionalLight(0x4040ff, 0.5);
            moonLight.position.set(-100, 200, 100);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            scene.add(moonLight);
            
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x111111,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid
            const gridHelper = new THREE.GridHelper(1000, 50, 0x333333, 0x222222);
            scene.add(gridHelper);
        }
        
        function createBuilding(x, y, z, height, type, phase) {
            const width = 3 + Math.random() * 4;
            const depth = 3 + Math.random() * 4;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create material with emissive windows
            const color = new THREE.Color();
            switch (type) {
                case 'h': color.setRGB(0.8, 0.2, 0.2); break;
                case 'l': color.setRGB(0.2, 0.8, 0.2); break;
                case 's': color.setRGB(0.2, 0.2, 0.8); break;
            }
            
            const material = new THREE.MeshLambertMaterial({
                color: color,
                emissive: color.clone().multiplyScalar(0.2)
            });
            
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, y + height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            
            scene.add(building);
            buildings.push(building);
            
            return building;
        }
        
        function createRoad(nodeA, nodeB) {
            const points = [nodeA.position, nodeB.position];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            
            const road = new THREE.Line(geometry, material);
            scene.add(road);
            roads.push(road);
            
            return road;
        }
        
        function createVehicleMesh() {
            const geometry = new THREE.BoxGeometry(2, 0.5, 1);
            const material = new THREE.MeshLambertMaterial({
                color: 0xffff00,
                emissive: 0x444400
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        function spawnVehicleBurst(position) {
            // Find nearby nodes for vehicle spawning
            const nearbyNodes = cityNodes.filter(node => 
                node.position.distanceTo(position) < 100
            );
            
            for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                if (nearbyNodes.length >= 2) {
                    const startNode = nearbyNodes[Math.floor(Math.random() * nearbyNodes.length)];
                    const targetNode = nearbyNodes[Math.floor(Math.random() * nearbyNodes.length)];
                    if (startNode !== targetNode) {
                        const vehicle = new Vehicle(startNode, targetNode);
                        vehicles.push(vehicle);
                    }
                }
            }
        }
        
        function createFireworks(position) {
            // Simple particle burst
            const particleCount = 20;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.2);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.8),
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.position.y += 20;
                
                // Random velocity
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        Math.random() * 10,
                        (Math.random() - 0.5) * 20
                    ),
                    life: 1.0
                };
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate particles
            const animateParticles = () => {
                particles.children.forEach((particle, index) => {
                    particle.userData.life -= 0.02;
                    if (particle.userData.life <= 0) {
                        particles.remove(particle);
                        return;
                    }
                    
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.1));
                    particle.userData.velocity.y -= 0.5; // gravity
                    particle.material.opacity = particle.userData.life;
                });
                
                if (particles.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }
        
        function initializeCity() {
            // Clear existing city
            cityNodes = [];
            buildings.forEach(building => scene.remove(building));
            buildings = [];
            roads.forEach(road => scene.remove(road));
            roads = [];
            vehicles.forEach(vehicle => vehicle.destroy());
            vehicles = [];
            
            // Create root district
            const depth = parseInt(controls.depth.value);
            const rootNode = new CityNode(0, 0, 0, 'h', 1, depth);
            cityNodes.push(rootNode);
            
            // Flatten node tree for easier access
            function collectNodes(node) {
                cityNodes.push(node);
                node.children.forEach(child => collectNodes(child));
            }
            collectNodes(rootNode);
            
            // Spawn initial vehicles
            setTimeout(() => {
                for (let i = 0; i < 5; i++) {
                    spawnVehicleBurst(new THREE.Vector3(0, 0, 0));
                }
            }, 1000);
        }
        
        // Microphone input
        async function initializeMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphone = audioContext.createMediaStreamSource(stream);
                analyzer = audioContext.createAnalyser();
                analyzer.fftSize = 256;
                microphone.connect(analyzer);
                return true;
            } catch (error) {
                console.log('Microphone access denied:', error);
                return false;
            }
        }
        
        function processMicrophoneInput() {
            if (!micActive || !analyzer) return;
            
            const bufferLength = analyzer.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyzer.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
            
            // Trigger city events on loud sounds
            if (average > 100) {
                const randomNode = cityNodes[Math.floor(Math.random() * cityNodes.length)];
                if (randomNode) {
                    randomNode.triggerHubEvent();
                }
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused) {
                time += 0.016;
                
                // Update city nodes
                if (cityNodes.length > 0) {
                    cityNodes[0].update(0.016); // Root node updates all children
                }
                
                // Update vehicles
                vehicles.forEach((vehicle, index) => {
                    vehicle.update(0.016);
                    
                    // Remove vehicles randomly to prevent buildup
                    if (Math.random() < 0.001) {
                        vehicle.destroy();
                        vehicles.splice(index, 1);
                    }
                });
                
                // Limit vehicle count
                if (vehicles.length > 50) {
                    const vehicle = vehicles.shift();
                    vehicle.destroy();
                }
                
                // Process microphone
                processMicrophoneInput();
                
                // Camera flythrough
                if (isFlying) {
                    const flyDuration = 10; // seconds
                    const elapsed = time - flyStartTime;
                    const progress = Math.min(elapsed / flyDuration, 1);
                    
                    if (progress < 1) {
                        // Smooth camera movement through city
                        const radius = 100 + Math.sin(elapsed * 0.5) * 50;
                        const height = 50 + Math.sin(elapsed * 0.3) * 30;
                        camera.position.x = Math.cos(elapsed * 0.2) * radius;
                        camera.position.z = Math.sin(elapsed * 0.2) * radius;
                        camera.position.y = height;
                        camera.lookAt(0, 0, 0);
                    } else {
                        // Return to original position
                        isFlying = false;
                        camera.position.copy(originalCameraPos);
                        camera.lookAt(0, 0, 0);
                    }
                }
            }
            
            renderer.render(scene, camera);
            
            // Update stats
            updateStats();
        }
        
        function updateStats() {
            document.getElementById('districtCount').textContent = cityNodes.length;
            document.getElementById('buildingCount').textContent = buildings.length;
            document.getElementById('trafficCount').textContent = vehicles.length;
            
            // Simple FPS counter
            const now = performance.now();
            if (!updateStats.lastTime) updateStats.lastTime = now;
            const fps = Math.round(1000 / (now - updateStats.lastTime));
            updateStats.lastTime = now;
            document.getElementById('fpsCounter').textContent = fps;
        }
        
        // Control functions
        function resetCity() {
            time = 0;
            initializeCity();
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        function flythrough() {
            if (!isFlying) {
                isFlying = true;
                flyStartTime = time;
                originalCameraPos = camera.position.clone();
            }
        }
        
        async function micToggle() {
            if (!micActive) {
                const success = await initializeMicrophone();
                if (success) {
                    micActive = true;
                    document.querySelector('button[onclick="micToggle()"]').textContent = 'ðŸŽ¤ ON';
                } else {
                    alert('Microphone access required for audio reactivity');
                }
            } else {
                micActive = false;
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                document.querySelector('button[onclick="micToggle()"]').textContent = 'ðŸŽ¤ OFF';
            }
        }
        
        // Event listeners
        function updateControlValues() {
            document.getElementById('depthValue').textContent = controls.depth.value;
            document.getElementById('speedValue').textContent = controls.speed.value;
            document.getElementById('spreadValue').textContent = controls.spread.value;
            document.getElementById('trafficValue').textContent = controls.traffic.value;
        }
        
        Object.values(controls).forEach(control => {
            control.addEventListener('input', updateControlValues);
        });
        
        controls.depth.addEventListener('change', resetCity);
        controls.spread.addEventListener('change', resetCity);
        
        // Event listeners setup function
        function setupEventListeners() {
            // Only setup if renderer exists
            if (!renderer || !renderer.domElement) {
                console.warn('Renderer not ready, skipping event listener setup');
                return;
            }
            
            // Mouse interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            function onMouseClick(event) {
                if (!camera || !scene) return;
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    // Plant new district at click location
                    const depth = Math.max(1, parseInt(controls.depth.value) - 2);
                    const type = ['h', 's', 'l'][Math.floor(Math.random() * 3)];
                    const newNode = new CityNode(point.x, 0, point.z, type, 0.8, depth);
                    cityNodes.push(newNode);
                    
                    // Connect to nearest existing node
                    let nearestNode = null;
                    let minDistance = Infinity;
                    cityNodes.forEach(node => {
                        if (node !== newNode) {
                            const distance = node.position.distanceTo(newNode.position);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestNode = node;
                            }
                        }
                    });
                    
                    if (nearestNode && minDistance < 150) {
                        createRoad(nearestNode, newNode);
                        spawnVehicleBurst(newNode.position);
                        createFireworks(newNode.position);
                    }
                }
            }
            
            function onWindowResize() {
                if (!camera || !renderer) return;
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Keyboard controls
            function onKeyDown(event) {
                switch(event.code) {
                    case 'Space':
                        togglePause();
                        event.preventDefault();
                        break;
                    case 'KeyR':
                        resetCity();
                        break;
                    case 'KeyF':
                        flythrough();
                        break;
                    case 'KeyM':
                        micToggle();
                        break;
                }
            }
            
            // Add event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            console.log('Event listeners setup complete');
        }
        
        // Initialize everything
        async function init() {
            // Wait a bit for Three.js to definitely load
            if (typeof THREE === 'undefined') {
                console.log('Waiting for Three.js...');
                for (let i = 0; i < 30; i++) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    if (typeof THREE !== 'undefined') break;
                }
            }
            
            if (typeof THREE === 'undefined') {
                console.error('Three.js failed to load, running fallback');
                runFallbackCity();
                return;
            }
            
            try {
                console.log('Three.js loaded, initializing 3D city...');
                initThreeJS();
                updateControlValues();
                initializeCity();
                
                // Setup event listeners after everything is initialized
                setupEventListeners();
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('interface').classList.remove('hidden');
                
                animate();
                
                console.log('ðŸŒƒ H/S/L City Matrix initialized!');
                console.log('ðŸŽ® Controls: Click to plant districts, SPACE=pause, R=reset, F=fly, M=mic');
                
            } catch (error) {
                console.error('Failed to initialize city:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff4444;">3D INITIALIZATION FAILED</div>
                    <div style="margin-top: 10px; font-size: 12px;">Error: ${error.message}</div>
                    <div style="margin-top: 10px; font-size: 12px;">Switching to 2D fallback...</div>
                `;
                setTimeout(() => runFallbackCity(), 2000);
            }
        }
        
        // Start when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
        
        // Expose global functions for buttons
        window.resetCity = resetCity;
        window.togglePause = togglePause;
        window.flythrough = flythrough;
        window.micToggle = micToggle;
        
    </script>
</body>
</html>